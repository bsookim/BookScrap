package com.shop.service;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.shop.Coupang;
import com.shop.CoupangItems;
import com.shop.common.HmacProductCreation;
import com.shop.common.JsonUtil;
import com.shop.dto.CoupangDto;
import com.shop.entity.CoupangAttributesRepository;
import com.shop.entity.CoupangImagesRepository;
import com.shop.entity.CoupangItemsRepository;
import com.shop.entity.CoupangRepository;

@Transactional
@Service
public class CoupangService {
	//쿠팡
	@Autowired CoupangRepository coupangRepository; 
	@Autowired CoupangItemsRepository coupangItemsRepository;
	@Autowired CoupangImagesRepository coupangImagesRepository;
	@Autowired CoupangAttributesRepository coupangAttributesRepository;
	@Autowired HmacProductCreation hmacProductCreation;
	
	

//	firstResult/maxResults specified with collection fetch; applying in memory 해결
	@Transactional
	public Page<CoupangDto>  getCoupangDto(){
		//1300개 상품이 옵션이  155
//		1,55
		Pageable pageable = PageRequest.of(6, 25);
        
		Page<Coupang> coupangPage = coupangRepository.findAll(pageable);
        //721부터 조심썸네일 다날리고 다시 입력
        //ENTITYGRAPH안써도 MEMORY문제 해결가능함 아래처럼 해결함 난 
        //map은 결과를 반환하는데 있어서 foreach를 사용함
        //무조건 ITEMS를 기준으로 UPDATE를 쳐라 COUPANG으로 치지마
		//영속성 컨텍스트 사용중에 update 하지마셈
        Pageable itemLimit = PageRequest.of(0, 200);
        List<Long> coupangIds = new ArrayList<>();
        List<Long> coupangItemIds = new ArrayList<>();
        List<CoupangDto> dtoList = coupangPage.getContent().stream()
							        .map(coupang -> {
							        	if(coupang.getItems() != null && !coupang.getItems().isEmpty()) {
							                List<CoupangItems> coupangItems = coupangItemsRepository.findAllByCoupangId(coupang.getId(), itemLimit);
							                
							                coupangIds.add(coupang.getId());
							                for(CoupangItems ci : coupangItems) {
							                    coupangItemIds.add(ci.getId());
							                }
							                //ATTRIBUTE를 정렬해야됨  
							                return new CoupangDto(coupang, coupangItems);
							            }
							            return new CoupangDto(coupang, Collections.emptyList());
							        })
							        .collect(Collectors.toList());
        	
        //아니 버크update 하려면 이런식으로 해야됨 ; 
        //왜냐면 조회중에 update를 하면 영속성컨텍스트 때문에 조회됐을때 영속성 컨텍스트에 있는 데이터들이 날라감 
        // 그래서 id값을 빼서 bulkupdate를 해야함.
        //그리고 clearAutomatically = true 영속성 컨텍스트 초기화 끝. 
    	for(Long id : coupangIds) {
    		
    		for(Long itemId : coupangItemIds) {
    			if(coupangItemIds!=null && itemId != 0)
    				
    			coupangItemsRepository.bulkUpdate(id, itemId);
    		}
    	}
    	
	    for (CoupangDto dto : dtoList) {
	    	if (dto.getItems() != null && !dto.getItems().isEmpty()) {
	            String json = JsonUtil.convertListToJson(dto);
	            hmacProductCreation.sendDataToCoupang(json);
	            try {
	                TimeUnit.SECONDS.sleep(1); 
	            } catch (InterruptedException e) {
	                Thread.currentThread().interrupt();
	            }
	        }
	    }
	    System.out.println("끝");
        return new PageImpl<>(dtoList, pageable, coupangPage.getTotalElements());

	}


	public void saveCoupang() {
		// TODO Auto-generated method stub
		
	}

}
 